// Depends on: helpers.js (ensureDbManager, areObjectsShallowEqual)
// Supabase: Uses window.supabaseClient

let supabaseShipmentSubscription = null; // For Supabase real-time subscription

// Helper to map Supabase row to JS object (for IndexedDB and UI)
function mapSupabaseToJsShipment(supabaseShipment) {
    if (!supabaseShipment) return null;
    return {
        id: supabaseShipment.id, // Assuming 'id' is UUID from Supabase
        shipmentDate: supabaseShipment.shipment_date, // ISO string
        status: supabaseShipment.status,
        trackingNumber: supabaseShipment.tracking_number,
        origin: supabaseShipment.origin,
        destination: supabaseShipment.destination,
        notes: supabaseShipment.notes,
        containerNumber: supabaseShipment.container_number,
        createdAt: supabaseShipment.created_at, // ISO string
        updatedAt: supabaseShipment.updated_at, // ISO string
        pendingSync: false // Default for items from Supabase
    };
}

// Helper to map JS object to Supabase row for insert/update
function mapJsToSupabaseShipment(jsShipment) {
    if (!jsShipment) return null;
    const supabaseData = {
        // id is auto-generated by Supabase on insert or used in .eq() for update
        shipment_date: jsShipment.shipmentDate ? new Date(jsShipment.shipmentDate).toISOString() : null,
        status: jsShipment.status,
        tracking_number: jsShipment.trackingNumber,
        origin: jsShipment.origin,
        destination: jsShipment.destination,
        notes: jsShipment.notes,
        container_number: jsShipment.containerNumber
        // created_at and updated_at are handled by Supabase
    };
    // Remove undefined fields
    Object.keys(supabaseData).forEach(key => supabaseData[key] === undefined && delete supabaseData[key]);
    return supabaseData;
}


const shipmentAPI_module = {
    async getShipments(params = {}) {
        await ensureDbManager();
        const { status, startDate, endDate, limit = 20, currentPage = 1 } = params;
        try {
            const idb = await window.indexedDBManager.initDB();
            const shipmentStoreName = window.indexedDBManager.STORE_NAMES.SHIPMENTS;

            const countInIDB = await window.indexedDBManager.countItems(shipmentStoreName);
            if (countInIDB === 0 && navigator.onLine && window.supabaseClient) {
                console.log("Shipments store in IndexedDB is empty, fetching from Supabase...");
                const { data: supabaseShipments, error: fetchError } = await window.supabaseClient
                    .from('shipments')
                    .select('*')
                    .order('shipment_date', { ascending: false });

                if (fetchError) throw fetchError;

                const itemsToCache = supabaseShipments.map(mapSupabaseToJsShipment);
                if (itemsToCache.length > 0) {
                    await window.indexedDBManager.bulkPutItems(shipmentStoreName, itemsToCache);
                }
            }

            const tx = idb.transaction(shipmentStoreName, 'readonly');
            const store = tx.objectStore(shipmentStoreName);
            // Assuming 'shipmentDate' is the correct index name in IndexedDB for JS objects.
            const index = store.index('shipmentDate'); 

            let range = null;
            if (startDate && endDate) {
                range = IDBKeyRange.bound(new Date(startDate).toISOString(), new Date(endDate).toISOString());
            } else if (startDate) {
                range = IDBKeyRange.lowerBound(new Date(startDate).toISOString());
            } else if (endDate) {
                range = IDBKeyRange.upperBound(new Date(endDate).toISOString());
            }

            const results = [];
            let totalItems = 0;
            const offset = (currentPage - 1) * limit;
            let cursorAdvancement = offset;
            let hasMoreDataForNextPage = false;

            await new Promise((resolveCount, rejectCount) => {
                const countCursorRequest = index.openCursor(range, 'prev');
                countCursorRequest.onsuccess = event => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const item = cursor.value; // JS object from IDB
                        let match = true;
                        if (status && item.status !== status) match = false;
                        if (match) totalItems++;
                        cursor.continue();
                    } else {
                        resolveCount();
                    }
                };
                countCursorRequest.onerror = event => rejectCount(event.target.error);
            });

            await new Promise((resolveCursor, rejectCursor) => {
                const cursorRequest = index.openCursor(range, 'prev');
                cursorRequest.onsuccess = event => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const item = cursor.value;
                        let match = true;
                        if (status && item.status !== status) match = false;

                        if (match) {
                            if (cursorAdvancement > 0) {
                                cursorAdvancement--;
                            } else if (results.length < limit) {
                                results.push(item);
                            } else {
                                hasMoreDataForNextPage = true;
                                resolveCursor();
                                return;
                            }
                        }
                        cursor.continue();
                    } else {
                        resolveCursor();
                    }
                };
                cursorRequest.onerror = event => rejectCursor(event.target.error);
            });

            return {
                data: results,
                pagination: {
                    currentPage: currentPage,
                    itemsPerPage: limit,
                    totalItems: totalItems,
                    totalPages: Math.ceil(totalItems / limit),
                    hasNextPage: hasMoreDataForNextPage
                }
            };
        } catch (error) {
            console.error("Error in shipmentAPI.getShipments (Supabase/IndexedDB):", error);
            return { data: [], pagination: { currentPage: currentPage, itemsPerPage: limit, totalItems: 0, totalPages: 0, hasNextPage: false } };
        }
    },

    async addShipment(shipmentDataJS) { // shipmentDataJS is in JS format
        await ensureDbManager();
        const payloadForSupabase = mapJsToSupabaseShipment(shipmentDataJS);
        
        if (navigator.onLine && window.supabaseClient) {
            const { data: newSupabaseShipment, error } = await window.supabaseClient
                .from('shipments')
                .insert(payloadForSupabase)
                .select()
                .single();

            if (error) throw error;
            
            const newJsShipment = mapSupabaseToJsShipment(newSupabaseShipment);
            await window.indexedDBManager.addItem(window.indexedDBManager.STORE_NAMES.SHIPMENTS, newJsShipment);
            console.log("Shipment added to Supabase and IndexedDB (online):", newJsShipment);
            return newJsShipment;
        } else {
            // Offline: Create a local ID for IndexedDB, actual ID will come from Supabase on sync
            const localJsShipment = {
                ...shipmentDataJS, // Keep original data
                id: `local_shipment_${new Date().getTime()}_${Math.random().toString(36).substr(2, 9)}`,
                createdAt: new Date().toISOString(), // Set client-side for offline
                updatedAt: new Date().toISOString(),
                pendingSync: true
            };
            await window.indexedDBManager.addItem(window.indexedDBManager.STORE_NAMES.SHIPMENTS, localJsShipment);
            await window.indexedDBManager.addItem(window.indexedDBManager.STORE_NAMES.OFFLINE_QUEUE, {
                storeName: 'shipments', // Target Supabase table name
                operation: 'add',
                payload: shipmentDataJS, // Original JS data, sync function will map it
                localId: localJsShipment.id,
                timestamp: new Date().toISOString()
            });
            console.log("Shipment added to IndexedDB (offline) and queued:", localJsShipment);
            return localJsShipment;
        }
    },

    async updateShipment(shipmentId, shipmentDataJS) { // shipmentId is Supabase UUID
        await ensureDbManager();
        const payloadForSupabase = mapJsToSupabaseShipment(shipmentDataJS);
        
        // Optimistic update for IndexedDB (JS format)
        const updatedShipmentForIDB = { 
            ...shipmentDataJS, 
            id: shipmentId, 
            updatedAt: new Date().toISOString() 
        };
        const existingShipmentFromIDB = await window.indexedDBManager.getItem(window.indexedDBManager.STORE_NAMES.SHIPMENTS, shipmentId);
        if (existingShipmentFromIDB && existingShipmentFromIDB.createdAt) {
            updatedShipmentForIDB.createdAt = existingShipmentFromIDB.createdAt; // Preserve original creation date
        }
        
        if (navigator.onLine && window.supabaseClient) {
            const { data: updatedSupabaseShipment, error } = await window.supabaseClient
                .from('shipments')
                .update(payloadForSupabase)
                .eq('id', shipmentId)
                .select()
                .single();

            if (error) throw error;

            const syncedJsShipment = mapSupabaseToJsShipment(updatedSupabaseShipment);
            await window.indexedDBManager.updateItem(window.indexedDBManager.STORE_NAMES.SHIPMENTS, syncedJsShipment);
            console.log("Shipment updated in Supabase and IndexedDB (online):", syncedJsShipment);
            return syncedJsShipment;
        } else {
            updatedShipmentForIDB.pendingSync = true;
            await window.indexedDBManager.updateItem(window.indexedDBManager.STORE_NAMES.SHIPMENTS, updatedShipmentForIDB);
            await window.indexedDBManager.addItem(window.indexedDBManager.STORE_NAMES.OFFLINE_QUEUE, {
                storeName: 'shipments',
                operation: 'update',
                itemId: shipmentId, // Supabase ID
                payload: shipmentDataJS, // Original JS data
                timestamp: new Date().toISOString()
            });
            console.log("Shipment updated in IndexedDB (offline) and queued:", updatedShipmentForIDB);
            return updatedShipmentForIDB;
        }
    },

    async deleteShipment(shipmentId) { // shipmentId is Supabase UUID
        await ensureDbManager();
        if (navigator.onLine && window.supabaseClient) {
            const { error } = await window.supabaseClient
                .from('shipments')
                .delete()
                .eq('id', shipmentId);

            if (error) throw error;

            await window.indexedDBManager.deleteItem(window.indexedDBManager.STORE_NAMES.SHIPMENTS, shipmentId);
            console.log("Shipment deleted from Supabase and IndexedDB (online):", shipmentId);
            return { id: shipmentId, deleted: true };
        } else {
            await window.indexedDBManager.deleteItem(window.indexedDBManager.STORE_NAMES.SHIPMENTS, shipmentId);
            await window.indexedDBManager.addItem(window.indexedDBManager.STORE_NAMES.OFFLINE_QUEUE, {
                storeName: 'shipments',
                operation: 'delete',
                itemId: shipmentId,
                timestamp: new Date().toISOString()
            });
            console.log("Shipment deleted from IndexedDB (offline) and queued:", shipmentId);
            return { id: shipmentId, deleted: true, pendingSync: true };
        }
    },

    listenToShipmentChanges(callback) {
        if (supabaseShipmentSubscription && typeof supabaseShipmentSubscription.unsubscribe === 'function') {
            console.log("Detaching existing Supabase shipment subscription.");
            supabaseShipmentSubscription.unsubscribe();
            supabaseShipmentSubscription = null;
        }

        ensureDbManager().then(() => {
            if (!window.supabaseClient) {
                console.error("Supabase client not available for shipment listener.");
                if (typeof callback === 'function') callback({ error: "Supabase client not available." });
                return;
            }

            supabaseShipmentSubscription = window.supabaseClient
                .channel('public:shipments')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'shipments' }, async (payload) => {
                    console.log('Supabase shipments change received:', payload);
                    await ensureDbManager();
                    let itemsToUpdate = [];
                    let itemIdsToDelete = [];
                    let changedCount = 0;

                    const { eventType, new: newRecord, old: oldRecord } = payload;
                    let jsShipmentData;

                    if (eventType === 'INSERT' || eventType === 'UPDATE') {
                        jsShipmentData = mapSupabaseToJsShipment(newRecord);
                        if (!jsShipmentData || !jsShipmentData.id) {
                             console.warn("Shipment change payload missing ID or invalid:", payload); return;
                        }
                        const existingItem = await window.indexedDBManager.getItem(window.indexedDBManager.STORE_NAMES.SHIPMENTS, jsShipmentData.id);
                        if (!existingItem || !areObjectsShallowEqual(existingItem, jsShipmentData, ['updatedAt', 'createdAt', 'pendingSync'])) {
                            itemsToUpdate.push(jsShipmentData);
                        }
                        changedCount++;
                    } else if (eventType === 'DELETE') {
                        // oldRecord contains the id of the deleted row
                        if (!oldRecord || !oldRecord.id) {
                            console.warn("Shipment delete payload missing ID:", payload); return;
                        }
                        itemIdsToDelete.push(oldRecord.id);
                        changedCount++;
                    }

                    if (itemsToUpdate.length > 0) {
                        await window.indexedDBManager.bulkPutItems(window.indexedDBManager.STORE_NAMES.SHIPMENTS, itemsToUpdate);
                    }
                    if (itemIdsToDelete.length > 0) {
                        await window.indexedDBManager.deleteItems(window.indexedDBManager.STORE_NAMES.SHIPMENTS, itemIdsToDelete);
                    }

                    if (changedCount > 0 && typeof callback === 'function') {
                        callback({ type: 'shipments_updated', count: changedCount });
                    }
                })
                .subscribe((status, err) => {
                    if (status === 'SUBSCRIBED') {
                        console.log('Successfully subscribed to Supabase shipments changes.');
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || err) {
                        console.error('Supabase shipments subscription error:', status, err);
                        if (typeof callback === 'function') callback({ error: `Supabase subscription failed: ${status}` });
                    }
                });
            console.log("Real-time listener (Supabase subscription) attached for shipments.");
        }).catch(error => {
            console.error("Failed to init DB for Supabase shipment listener:", error);
            if (typeof callback === 'function') callback({ error: "IndexedDB init failed for shipment listener." });
        });

        return () => {
            if (supabaseShipmentSubscription && typeof supabaseShipmentSubscription.unsubscribe === 'function') {
                supabaseShipmentSubscription.unsubscribe();
                supabaseShipmentSubscription = null;
                console.log("Supabase shipment listener detached by returned function.");
            }
        };
    },

    detachShipmentListener() {
        if (supabaseShipmentSubscription && typeof supabaseShipmentSubscription.unsubscribe === 'function') {
            supabaseShipmentSubscription.unsubscribe();
            supabaseShipmentSubscription = null;
            console.log("Real-time listener for Supabase shipments detached.");
        }
    }
};

window.shipmentAPI = shipmentAPI_module;
console.log("shipmentAPI.js executed and window.shipmentAPI assigned (Supabase version)");
